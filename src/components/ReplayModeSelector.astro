---
// Component for selecting replay view mode
interface Props {
    players?: Array<{
        name: string;
        character: string;
        icon?: string;
        color?: string;
    }>;
    npcs?: Array<{
        name: string;
        icon?: string;
        color?: string;
    }>;
}

const { players = [], npcs = [] } = Astro.props;

// Serialize character data for client-side use
const characterData = JSON.stringify({
    players,
    npcs,
});
---

<div class="replay-mode-selector" data-characters={characterData}>
    <div class="mode-label">Modo de vista:</div>
    <div class="mode-buttons">
        <button class="mode-btn active" data-mode="completo">
            <span class="mode-icon">üìñ</span>
            <span class="mode-name">Completo</span>
        </button>
        <button class="mode-btn" data-mode="novela">
            <span class="mode-icon">üé≠</span>
            <span class="mode-name">Novela</span>
        </button>
        <button class="mode-btn" data-mode="mesa">
            <span class="mode-icon">üé≤</span>
            <span class="mode-name">Mesa</span>
        </button>
        <button class="mode-btn" data-mode="reglas">
            <span class="mode-icon">üìê</span>
            <span class="mode-name">Reglas</span>
        </button>
    </div>
</div>

<style>
    .replay-mode-selector {
        background: var(--color-background-alt);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        position: sticky;
        top: 80px;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .mode-label {
        font-weight: 700;
        font-size: 0.875rem;
        color: var(--color-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .mode-buttons {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0.5rem;
    }

    .mode-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.25rem;
        padding: 0.75rem 0.5rem;
        background: white;
        border: 2px solid var(--color-border);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: var(--font-comic);
    }

    .mode-btn:hover {
        border-color: var(--color-primary);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .mode-btn.active {
        background: var(--color-primary);
        border-color: var(--color-primary);
        color: white;
    }

    .mode-icon {
        font-size: 1.5rem;
    }

    .mode-name {
        font-size: 0.75rem;
        font-weight: 600;
        text-align: center;
    }

    @media (max-width: 768px) {
        .replay-mode-selector {
            position: sticky;
            top: 60px;
            padding: 0.75rem;
        }

        .mode-buttons {
            grid-template-columns: repeat(2, 1fr);
        }

        .mode-btn {
            padding: 0.5rem;
        }

        .mode-icon {
            font-size: 1.25rem;
        }

        .mode-name {
            font-size: 0.7rem;
        }
    }

    @media (max-width: 480px) {
        .mode-label {
            font-size: 0.75rem;
        }

        .mode-buttons {
            gap: 0.375rem;
        }
    }
</style>

<script>
    // Client-side script for mode switching and content detection
    document.addEventListener("DOMContentLoaded", () => {
        console.log("=== ReplayModeSelector: DOMContentLoaded fired ===");

        const buttons = document.querySelectorAll(".mode-btn");
        const replayContent = document.querySelector(".lore-text");

        if (!replayContent) {
            console.error("ERROR: .lore-text element not found!");
            return;
        }

        const category = replayContent.getAttribute("data-category");
        console.log("Page category:", category);

        // Only process if this is an actual-plays page
        if (category !== "actual-plays") {
            console.log("Not an actual-plays page, skipping");
            return;
        }

        // STEP 1: Process content to add data-type attributes
        console.log("=== STEP 1: Processing replay content ===");
        let paragraphs = replayContent.querySelectorAll("p");
        console.log(`Found ${paragraphs.length} paragraphs`);

        // STEP 1.1: Split paragraphs that contain multiple tags
        console.log("=== STEP 1.1: Splitting multi-tag paragraphs ===");
        const tagPattern = /(NARR:|CHAR\[|PLAYER\[|GM:|ROLL\[|RULE\[|META:)/g;

        paragraphs.forEach((p) => {
            const html = p.innerHTML;
            const matches = html.match(tagPattern);

            if (matches && matches.length > 1) {
                // This paragraph has multiple tags, split it
                console.log("Splitting paragraph with", matches.length, "tags");

                // Split by tag patterns
                const parts = html.split(
                    /(NARR:|CHAR\[[^\]]+\]:|PLAYER\[[^\]]+\]:|GM:|ROLL\[[^\]]+\]:|RULE\[[^\]]+\]:|META:)/,
                );

                const newParagraphs = [];
                let currentContent = "";

                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];

                    if (
                        part.match(
                            /^(NARR:|CHAR\[|PLAYER\[|GM:|ROLL\[|RULE\[|META:)/,
                        )
                    ) {
                        // This is a tag
                        if (currentContent.trim()) {
                            newParagraphs.push(currentContent.trim());
                        }
                        currentContent = part;
                    } else if (part.trim()) {
                        currentContent += part;
                    }
                }

                if (currentContent.trim()) {
                    newParagraphs.push(currentContent.trim());
                }

                // Replace the original paragraph with new ones
                if (newParagraphs.length > 1) {
                    const fragment = document.createDocumentFragment();
                    newParagraphs.forEach((content) => {
                        const newP = document.createElement("p");
                        newP.innerHTML = content;
                        fragment.appendChild(newP);
                    });
                    p.replaceWith(fragment);
                }
            }
        });

        // Re-query paragraphs after splitting
        paragraphs = replayContent.querySelectorAll("p");
        console.log(`After splitting: ${paragraphs.length} paragraphs`);

        let taggedCount = 0;
        const tagCounts = {};

        paragraphs.forEach((p, index) => {
            const text = p.textContent.trim();
            let dataType = null;

            if (text.startsWith("NARR:")) {
                dataType = "narr";
            } else if (text.startsWith("CHAR[") || text.startsWith("CHAR:")) {
                dataType = "char";
            } else if (
                text.startsWith("PLAYER[") ||
                text.startsWith("PLAYER:")
            ) {
                dataType = "player";
            } else if (text.startsWith("GM:")) {
                dataType = "gm";
            } else if (text.startsWith("ROLL[") || text.startsWith("ROLL:")) {
                dataType = "roll";
            } else if (text.startsWith("RULE[") || text.startsWith("RULE:")) {
                dataType = "rule";
            } else if (text.startsWith("META:")) {
                dataType = "meta";
            }

            if (dataType) {
                p.setAttribute("data-type", dataType);
                taggedCount++;
                tagCounts[dataType] = (tagCounts[dataType] || 0) + 1;

                if (index < 3) {
                    console.log(
                        `  [${index}] Tagged '${dataType}': ${text.substring(0, 40)}...`,
                    );
                }
            }
        });

        console.log(`Tagged ${taggedCount} / ${paragraphs.length} paragraphs`);
        console.log("Tag distribution:", tagCounts);

        // STEP 1.5: Add character icons to CHAR dialogues
        console.log("=== STEP 1.5: Adding character icons ===");
        const selector = document.querySelector(".replay-mode-selector");
        const charactersJson = selector?.getAttribute("data-characters");

        if (charactersJson) {
            try {
                const { players, npcs } = JSON.parse(charactersJson);
                const allCharacters = [...players, ...npcs];
                console.log(
                    "Character data loaded:",
                    allCharacters.length,
                    "characters",
                );

                // Process CHAR, PLAYER, and ROLL paragraphs to add icons
                paragraphs.forEach((p) => {
                    const dataType = p.getAttribute("data-type");

                    if (
                        dataType === "char" ||
                        dataType === "player" ||
                        dataType === "roll"
                    ) {
                        const text = p.textContent.trim();
                        let match = null;
                        let tagPattern = null;

                        if (dataType === "char") {
                            match = text.match(/^CHAR\[([^\]]+)\]:/);
                            tagPattern = /^CHAR\[[^\]]+\]:\s*/;
                        } else if (dataType === "player") {
                            match = text.match(/^PLAYER\[([^\]]+)\]:/);
                            tagPattern = /^PLAYER\[[^\]]+\]:\s*/;
                        } else if (dataType === "roll") {
                            match = text.match(/^ROLL\[([^\]]+)\]:/);
                            tagPattern = /^ROLL\[[^\]]+\]:\s*/;
                        }

                        if (match && tagPattern) {
                            const charName = match[1].trim();

                            // Find character in players or NPCs
                            const character = allCharacters.find(
                                (c) =>
                                    c.character === charName ||
                                    c.name === charName,
                            );

                            if (character) {
                                // Create icon element
                                const iconSpan = document.createElement("span");
                                iconSpan.className =
                                    dataType === "char"
                                        ? "char-icon"
                                        : "player-icon";

                                // For ROLL, use dice emoji instead of character icon
                                if (dataType === "roll") {
                                    const diceSpan =
                                        document.createElement("span");
                                    diceSpan.className = "dice-icon";
                                    diceSpan.textContent = "üé≤";
                                    iconSpan.appendChild(diceSpan);
                                } else if (
                                    dataType === "char" &&
                                    character.icon
                                ) {
                                    // For CHAR, show character icon if available
                                    const img = document.createElement("img");
                                    img.src = character.icon;
                                    img.alt =
                                        character.character || character.name;
                                    img.className = "char-avatar";
                                    iconSpan.appendChild(img);
                                }
                                // For PLAYER, no icon

                                const nameSpan = document.createElement("span");
                                nameSpan.className =
                                    dataType === "char"
                                        ? "char-name"
                                        : "player-name";

                                // For PLAYER and ROLL, show player name; for CHAR, show character name
                                if (
                                    dataType === "player" ||
                                    dataType === "roll"
                                ) {
                                    nameSpan.textContent = character.name; // Player name
                                } else {
                                    nameSpan.textContent =
                                        character.character || character.name; // Character name
                                }

                                if (character.color) {
                                    nameSpan.style.color = character.color;
                                }
                                iconSpan.appendChild(nameSpan);

                                // Insert at the beginning of the paragraph
                                p.insertBefore(iconSpan, p.firstChild);

                                // Hide the original tag
                                const firstChild = p.childNodes[1]; // After icon
                                if (
                                    firstChild &&
                                    firstChild.nodeType === Node.TEXT_NODE &&
                                    firstChild.textContent
                                ) {
                                    firstChild.textContent =
                                        firstChild.textContent.replace(
                                            tagPattern,
                                            "",
                                        );
                                }
                            }
                        }
                    }
                });

                // Process GM paragraphs to add "Guionista" label
                paragraphs.forEach((p) => {
                    if (p.getAttribute("data-type") === "gm") {
                        const text = p.textContent.trim();
                        if (text.startsWith("GM:")) {
                            const labelSpan = document.createElement("span");
                            labelSpan.className = "gm-label";
                            labelSpan.textContent = "Guionista";

                            p.insertBefore(labelSpan, p.firstChild);

                            // Hide the original GM: tag
                            const firstChild = p.childNodes[1];
                            if (
                                firstChild &&
                                firstChild.nodeType === Node.TEXT_NODE &&
                                firstChild.textContent
                            ) {
                                firstChild.textContent =
                                    firstChild.textContent.replace(
                                        /^GM:\s*/,
                                        "",
                                    );
                            }
                        }
                    }
                });

                // Process RULE paragraphs to add book icon
                paragraphs.forEach((p) => {
                    if (p.getAttribute("data-type") === "rule") {
                        const text = p.textContent.trim();
                        const match = text.match(/^RULE\[([^\]]+)\]:/);

                        if (match) {
                            const ruleRef = match[1].trim();

                            const iconSpan = document.createElement("span");
                            iconSpan.className = "rule-icon";

                            const bookSpan = document.createElement("span");
                            bookSpan.className = "book-icon";
                            bookSpan.textContent = "üìê";
                            iconSpan.appendChild(bookSpan);

                            const refSpan = document.createElement("span");
                            refSpan.className = "rule-ref";
                            refSpan.textContent = ruleRef;
                            iconSpan.appendChild(refSpan);

                            p.insertBefore(iconSpan, p.firstChild);

                            // Hide the original RULE[ref]: tag
                            const firstChild = p.childNodes[1];
                            if (
                                firstChild &&
                                firstChild.nodeType === Node.TEXT_NODE &&
                                firstChild.textContent
                            ) {
                                firstChild.textContent =
                                    firstChild.textContent.replace(
                                        /^RULE\[[^\]]+\]:\s*/,
                                        "",
                                    );
                            }
                        }
                    }
                });

                // Process NARR paragraphs to hide the tag
                paragraphs.forEach((p) => {
                    if (p.getAttribute("data-type") === "narr") {
                        const text = p.textContent.trim();
                        if (text.startsWith("NARR:")) {
                            // Hide the NARR: tag
                            const firstChild = p.firstChild;
                            if (
                                firstChild &&
                                firstChild.nodeType === Node.TEXT_NODE &&
                                firstChild.textContent
                            ) {
                                firstChild.textContent =
                                    firstChild.textContent.replace(
                                        /^NARR:\s*/,
                                        "",
                                    );
                            }
                        }
                    }
                });

                // Process META paragraphs to hide the tag
                paragraphs.forEach((p) => {
                    if (p.getAttribute("data-type") === "meta") {
                        const text = p.textContent.trim();
                        if (text.startsWith("META:")) {
                            // Hide the META: tag
                            const firstChild = p.firstChild;
                            if (
                                firstChild &&
                                firstChild.nodeType === Node.TEXT_NODE &&
                                firstChild.textContent
                            ) {
                                firstChild.textContent =
                                    firstChild.textContent.replace(
                                        /^META:\s*/,
                                        "",
                                    );
                            }
                        }
                    }
                });

                // Process @scene and @location markers
                console.log("=== Processing @scene and @location markers ===");

                // FIRST: Split paragraphs that contain both @scene and @location
                const paragraphsArray = Array.from(paragraphs);
                paragraphsArray.forEach((p) => {
                    const html = p.innerHTML;
                    // Check if paragraph contains both markers
                    if (
                        html.includes("@scene:") &&
                        html.includes("@location:")
                    ) {
                        console.log(
                            "Found paragraph with both markers, splitting...",
                        );
                        // Split by <br> or <br/> or <br />
                        const parts = html.split(/<br\s*\/?>/);

                        if (parts.length > 1) {
                            // Create new paragraphs for each part
                            const fragment = document.createDocumentFragment();
                            parts.forEach((part) => {
                                if (part.trim()) {
                                    const newP = document.createElement("p");
                                    newP.innerHTML = part.trim();
                                    fragment.appendChild(newP);
                                }
                            });
                            p.replaceWith(fragment);
                        }
                    }
                });

                // Re-query paragraphs after splitting
                paragraphs = replayContent.querySelectorAll("p");
                console.log(
                    `After splitting scene/location: ${paragraphs.length} paragraphs`,
                );

                // NOW process the markers
                paragraphs.forEach((p) => {
                    const text = p.textContent.trim();
                    const htmlContent = p.innerHTML.trim();

                    // Debug: log first 100 chars of each paragraph
                    if (
                        htmlContent.includes("@scene") ||
                        htmlContent.includes("@location")
                    ) {
                        console.log(
                            "Found marker paragraph:",
                            htmlContent.substring(0, 100),
                        );
                    }

                    // Process @scene markers
                    if (text.startsWith("@scene:")) {
                        console.log("Processing @scene marker");
                        const sceneMatch = text.match(/@scene:\s*(\d+)/);
                        if (sceneMatch) {
                            const sceneNumber = sceneMatch[1];

                            // Create badge
                            const badge = document.createElement("span");
                            badge.className = "scene-badge";

                            const icon = document.createElement("span");
                            icon.className = "scene-icon";
                            icon.textContent = "üé¨";
                            badge.appendChild(icon);

                            const label = document.createElement("span");
                            label.className = "scene-label";
                            label.textContent = `Escena ${sceneNumber}`;
                            badge.appendChild(label);

                            // Check if next sibling is a location marker
                            const nextP = p.nextElementSibling;
                            let locationElement = null;

                            if (
                                nextP &&
                                nextP.innerHTML.trim().startsWith("@location:")
                            ) {
                                console.log(
                                    "Found location marker right after scene",
                                );
                                const locationMatch =
                                    nextP.innerHTML.match(/@location:\s*(.+)/);
                                if (locationMatch) {
                                    let locationContent =
                                        locationMatch[1].trim();

                                    // Create location element
                                    locationElement =
                                        document.createElement("span");
                                    locationElement.className =
                                        "location-inline";

                                    const locationLabel =
                                        document.createElement("strong");
                                    locationLabel.textContent =
                                        "Localizaci√≥n: ";
                                    locationLabel.style.color = "#f5576c";

                                    const contentSpan =
                                        document.createElement("span");
                                    contentSpan.innerHTML = locationContent;

                                    locationElement.appendChild(locationLabel);
                                    locationElement.appendChild(contentSpan);

                                    // Mark next paragraph for removal
                                    nextP.setAttribute("data-remove", "true");
                                }
                            }

                            // Create container for scene and location
                            const container = document.createElement("div");
                            container.className = "scene-location-container";
                            container.appendChild(badge);

                            if (locationElement) {
                                container.appendChild(locationElement);
                            }

                            // Replace paragraph content
                            p.innerHTML = "";
                            p.appendChild(container);
                            p.setAttribute("data-type", "scene-marker");
                            console.log(
                                "Scene badge created for scene",
                                sceneNumber,
                            );
                        }
                    }

                    // Process standalone @location markers (not already processed with scene)
                    if (
                        htmlContent.startsWith("@location:") &&
                        !p.hasAttribute("data-remove")
                    ) {
                        console.log("Processing standalone @location marker");
                        const locationMatch =
                            htmlContent.match(/@location:\s*(.+)/);
                        if (locationMatch) {
                            let locationContent = locationMatch[1].trim();

                            // Create bold "Localizaci√≥n" label
                            const label = document.createElement("strong");
                            label.textContent = "Localizaci√≥n: ";
                            label.style.color = "#f5576c";

                            // Create a span to hold the location content (with links)
                            const contentSpan = document.createElement("span");
                            contentSpan.innerHTML = locationContent;

                            // Replace paragraph content
                            p.innerHTML = "";
                            p.appendChild(label);
                            p.appendChild(contentSpan);
                            p.setAttribute("data-type", "location-marker");
                            console.log("Standalone location label created");
                        }
                    }
                });

                // Remove paragraphs marked for removal
                replayContent
                    .querySelectorAll('p[data-remove="true"]')
                    .forEach((p) => p.remove());
                console.log("Character icons added");
            } catch (e) {
                console.error("Error parsing character data:", e);
            }
        }

        // STEP 2: Setup mode switching
        console.log("=== STEP 2: Setting up mode switching ===");

        // Load saved mode from localStorage
        const savedMode = localStorage.getItem("replayViewMode") || "completo";
        setMode(savedMode);

        buttons.forEach((button) => {
            button.addEventListener("click", () => {
                const mode = button.dataset.mode;
                setMode(mode);
                localStorage.setItem("replayViewMode", mode);
            });
        });

        function setMode(mode) {
            // Update active button
            buttons.forEach((btn) => {
                btn.classList.toggle("active", btn.dataset.mode === mode);
            });

            // Update content visibility
            if (replayContent) {
                replayContent.className = `lore-text mode-${mode}`;
                console.log(`Mode changed to: ${mode}`);
                console.log(`Content class: ${replayContent.className}`);

                // Count visible paragraphs
                const allP = replayContent.querySelectorAll("p");

                // DEBUG: Check if paragraphs have data-type
                const withDataType = Array.from(allP).filter((p) =>
                    p.hasAttribute("data-type"),
                );
                console.log(
                    `Paragraphs with data-type: ${withDataType.length} / ${allP.length}`,
                );
                if (withDataType.length > 0) {
                    console.log(
                        "Sample data-types:",
                        withDataType
                            .slice(0, 3)
                            .map((p) => p.getAttribute("data-type"))
                            .join(", "),
                    );
                }

                const visibleP = Array.from(allP).filter((p) => {
                    const style = window.getComputedStyle(p);
                    return style.display !== "none";
                });
                console.log(
                    `Visible paragraphs: ${visibleP.length} / ${allP.length}`,
                );

                // DEBUG: Check CSS for a paragraph that should be hidden
                if (mode !== "completo" && withDataType.length > 0) {
                    const shouldBeHidden = Array.from(allP).find((p) => {
                        const type = p.getAttribute("data-type");
                        if (mode === "novela")
                            return [
                                "player",
                                "gm",
                                "roll",
                                "rule",
                                "meta",
                            ].includes(type);
                        if (mode === "mesa")
                            return ["roll", "rule", "meta"].includes(type);
                        if (mode === "reglas")
                            return ["char", "player", "gm", "meta"].includes(
                                type,
                            );
                        return false;
                    });

                    if (shouldBeHidden) {
                        const computedStyle =
                            window.getComputedStyle(shouldBeHidden);
                        console.log("DEBUG: Paragraph that should be hidden:");
                        console.log(
                            "  data-type:",
                            shouldBeHidden.getAttribute("data-type"),
                        );
                        console.log("  display:", computedStyle.display);
                        console.log("  visibility:", computedStyle.visibility);
                        console.log("  classes:", shouldBeHidden.className);
                        console.log(
                            "  parent classes:",
                            shouldBeHidden.parentElement?.className,
                        );
                    }
                }

                // Debug: show first few visible paragraphs
                if (visibleP.length < allP.length) {
                    console.log("Sample visible paragraphs:");
                    visibleP.slice(0, 3).forEach((p, i) => {
                        console.log(
                            `  ${i}: ${p.getAttribute("data-type")} - ${p.textContent.substring(0, 40)}...`,
                        );
                    });
                }
            } else {
                console.error("Replay content element not found!");
            }
        }

        console.log("=== Setup complete ===");
    });
</script>
