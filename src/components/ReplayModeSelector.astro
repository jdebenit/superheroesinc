---
// Component for selecting replay view mode
interface Props {
    players?: Array<{
        name: string;
        character: string;
        icon?: string;
        color?: string;
    }>;
    npcs?: Array<{
        name: string;
        icon?: string;
        color?: string;
    }>;
}

const { players = [], npcs = [] } = Astro.props;

// Serialize character data for client-side use
const characterData = JSON.stringify({
    players,
    npcs,
});
---

<div class="replay-mode-selector" data-characters={characterData}>
    <div class="mode-label">Modo de vista:</div>
    <div class="mode-buttons">
        <button class="mode-btn active" data-mode="completo">
            <span class="mode-icon">üìñ</span>
            <span class="mode-name">Completo</span>
        </button>
        <button class="mode-btn" data-mode="novela">
            <span class="mode-icon">üé≠</span>
            <span class="mode-name">Novela</span>
        </button>
        <button class="mode-btn" data-mode="mesa">
            <span class="mode-icon">üé≤</span>
            <span class="mode-name">Mesa</span>
        </button>
        <button class="mode-btn" data-mode="reglas">
            <span class="mode-icon">üìê</span>
            <span class="mode-name">Reglas</span>
        </button>
    </div>
</div>

<style>
    .replay-mode-selector {
        background: var(--color-background-alt);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        position: sticky;
        top: 80px;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .mode-label {
        font-weight: 700;
        font-size: 0.875rem;
        color: var(--color-secondary);
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .mode-buttons {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0.5rem;
    }

    .mode-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.25rem;
        padding: 0.75rem 0.5rem;
        background: white;
        border: 2px solid var(--color-border);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: var(--font-comic);
    }

    .mode-btn:hover {
        border-color: var(--color-primary);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .mode-btn.active {
        background: var(--color-primary);
        border-color: var(--color-primary);
        color: white;
    }

    .mode-icon {
        font-size: 1.5rem;
    }

    .mode-name {
        font-size: 0.75rem;
        font-weight: 600;
        text-align: center;
    }

    @media (max-width: 768px) {
        .replay-mode-selector {
            position: sticky;
            top: 60px;
            padding: 0.75rem;
        }

        .mode-buttons {
            grid-template-columns: repeat(2, 1fr);
        }

        .mode-btn {
            padding: 0.5rem;
        }

        .mode-icon {
            font-size: 1.25rem;
        }

        .mode-name {
            font-size: 0.7rem;
        }
    }

    @media (max-width: 480px) {
        .mode-label {
            font-size: 0.75rem;
        }

        .mode-buttons {
            gap: 0.375rem;
        }
    }
</style>

<script>
    // Client-side script for mode switching and content detection
    document.addEventListener("DOMContentLoaded", () => {
        console.log("=== ReplayModeSelector: DOMContentLoaded fired ===");

        const buttons = document.querySelectorAll(".mode-btn");
        const replayContent = document.querySelector(".lore-text");

        if (!replayContent) {
            console.error("ERROR: .lore-text element not found!");
            return;
        }

        const category = replayContent.getAttribute("data-category");
        console.log("Page category:", category);

        // Only process if this is an actual-plays page
        if (category !== "actual-plays") {
            console.log("Not an actual-plays page, skipping");
            return;
        }

        // STEP 1: Process content to add data-type attributes
        console.log("=== STEP 1: Processing replay content ===");
        let paragraphs = replayContent.querySelectorAll("p");
        console.log(`Found ${paragraphs.length} paragraphs`);

        // STEP 1.1: Split paragraphs that contain multiple tags
        console.log("=== STEP 1.1: Splitting multi-tag paragraphs ===");
        const tagPattern = /(NARR:|CHAR\[|PLAYER\[|GM:|ROLL\[|RULE\[|META:)/g;

        paragraphs.forEach((p) => {
            const html = p.innerHTML;
            const matches = html.match(tagPattern);

            if (matches && matches.length > 1) {
                // This paragraph has multiple tags, split it
                console.log("Splitting paragraph with", matches.length, "tags");

                // Split by tag patterns
                const parts = html.split(
                    /(NARR:|CHAR\[[^\]]+\]:|PLAYER\[[^\]]+\]:|GM:|ROLL\[[^\]]+\]:|RULE\[[^\]]+\]:|META:)/,
                );

                const newParagraphs = [];
                let currentContent = "";

                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];

                    if (
                        part.match(
                            /^(NARR:|CHAR\[|PLAYER\[|GM:|ROLL\[|RULE\[|META:)/,
                        )
                    ) {
                        // This is a tag
                        if (currentContent.trim()) {
                            newParagraphs.push(currentContent.trim());
                        }
                        currentContent = part;
                    } else if (part.trim()) {
                        currentContent += part;
                    }
                }

                if (currentContent.trim()) {
                    newParagraphs.push(currentContent.trim());
                }

                // Replace the original paragraph with new ones
                if (newParagraphs.length > 1) {
                    const fragment = document.createDocumentFragment();
                    newParagraphs.forEach((content) => {
                        const newP = document.createElement("p");
                        newP.innerHTML = content;
                        fragment.appendChild(newP);
                    });
                    p.replaceWith(fragment);
                }
            }
        });

        // Re-query paragraphs after splitting
        paragraphs = replayContent.querySelectorAll("p");
        console.log(`After splitting: ${paragraphs.length} paragraphs`);

        let taggedCount = 0;
        const tagCounts = {};

        paragraphs.forEach((p, index) => {
            const text = p.textContent.trim();
            let dataType = null;

            if (text.startsWith("NARR:")) {
                dataType = "narr";
            } else if (text.startsWith("CHAR[") || text.startsWith("CHAR:")) {
                dataType = "char";
            } else if (
                text.startsWith("PLAYER[") ||
                text.startsWith("PLAYER:")
            ) {
                dataType = "player";
            } else if (text.startsWith("GM:")) {
                dataType = "gm";
            } else if (text.startsWith("ROLL[") || text.startsWith("ROLL:")) {
                dataType = "roll";
            } else if (text.startsWith("RULE[") || text.startsWith("RULE:")) {
                dataType = "rule";
            } else if (text.startsWith("META:")) {
                dataType = "meta";
            }

            if (dataType) {
                p.setAttribute("data-type", dataType);
                taggedCount++;
                tagCounts[dataType] = (tagCounts[dataType] || 0) + 1;

                if (index < 3) {
                    console.log(
                        `  [${index}] Tagged '${dataType}': ${text.substring(0, 40)}...`,
                    );
                }
            }
        });

        console.log(`Tagged ${taggedCount} / ${paragraphs.length} paragraphs`);
        console.log("Tag distribution:", tagCounts);

        // STEP 1.5: Add character icons to CHAR dialogues
        console.log("=== STEP 1.5: Adding character icons ===");
        const selector = document.querySelector(".replay-mode-selector");
        const charactersJson = selector?.getAttribute("data-characters");

        if (charactersJson) {
            try {
                const { players, npcs } = JSON.parse(charactersJson);
                const allCharacters = [...players, ...npcs];
                console.log(
                    "Character data loaded:",
                    allCharacters.length,
                    "characters",
                );

                // Process CHAR, PLAYER, and ROLL paragraphs to add icons
                paragraphs.forEach((p) => {
                    const dataType = p.getAttribute("data-type");

                    if (
                        dataType === "char" ||
                        dataType === "player" ||
                        dataType === "roll"
                    ) {
                        const text = p.textContent.trim();
                        let match = null;
                        let tagPattern = null;

                        if (dataType === "char") {
                            match = text.match(/^CHAR\[([^\]]+)\]:/);
                            tagPattern = /^CHAR\[[^\]]+\]:\s*/;
                        } else if (dataType === "player") {
                            match = text.match(/^PLAYER\[([^\]]+)\]:/);
                            tagPattern = /^PLAYER\[[^\]]+\]:\s*/;
                        } else if (dataType === "roll") {
                            match = text.match(/^ROLL\[([^\]]+)\]:/);
                            tagPattern = /^ROLL\[[^\]]+\]:\s*/;
                        }

                        if (match && tagPattern) {
                            const charName = match[1].trim();

                            // Find character in players or NPCs
                            const character = allCharacters.find(
                                (c) =>
                                    c.character === charName ||
                                    c.name === charName,
                            );

                            if (character) {
                                // Create icon element
                                const iconSpan = document.createElement("span");
                                iconSpan.className =
                                    dataType === "char"
                                        ? "char-icon"
                                        : "player-icon";

                                // For ROLL, use dice emoji instead of character icon
                                if (dataType === "roll") {
                                    const diceSpan =
                                        document.createElement("span");
                                    diceSpan.className = "dice-icon";
                                    diceSpan.textContent = "üé≤";
                                    iconSpan.appendChild(diceSpan);
                                } else if (
                                    dataType === "char" &&
                                    character.icon
                                ) {
                                    // For CHAR, show character icon if available
                                    const img = document.createElement("img");
                                    img.src = character.icon;
                                    img.alt =
                                        character.character || character.name;
                                    img.className = "char-avatar";
                                    iconSpan.appendChild(img);
                                }
                                // For PLAYER, no icon

                                const nameSpan = document.createElement("span");
                                nameSpan.className =
                                    dataType === "char"
                                        ? "char-name"
                                        : "player-name";

                                // For PLAYER and ROLL, show player name; for CHAR, show character name
                                if (
                                    dataType === "player" ||
                                    dataType === "roll"
                                ) {
                                    nameSpan.textContent = character.name; // Player name
                                } else {
                                    nameSpan.textContent =
                                        character.character || character.name; // Character name
                                }

                                if (character.color) {
                                    nameSpan.style.color = character.color;
                                }
                                iconSpan.appendChild(nameSpan);

                                // Insert at the beginning of the paragraph
                                p.insertBefore(iconSpan, p.firstChild);

                                // Hide the original tag
                                const firstChild = p.childNodes[1]; // After icon
                                if (
                                    firstChild &&
                                    firstChild.nodeType === Node.TEXT_NODE &&
                                    firstChild.textContent
                                ) {
                                    firstChild.textContent =
                                        firstChild.textContent.replace(
                                            tagPattern,
                                            "",
                                        );
                                }
                            }
                        }
                    }
                });

                // Process GM paragraphs to add "Guionista" label
                paragraphs.forEach((p) => {
                    if (p.getAttribute("data-type") === "gm") {
                        const text = p.textContent.trim();
                        if (text.startsWith("GM:")) {
                            const labelSpan = document.createElement("span");
                            labelSpan.className = "gm-label";
                            labelSpan.textContent = "Guionista";

                            p.insertBefore(labelSpan, p.firstChild);

                            // Hide the original GM: tag
                            const firstChild = p.childNodes[1];
                            if (
                                firstChild &&
                                firstChild.nodeType === Node.TEXT_NODE &&
                                firstChild.textContent
                            ) {
                                firstChild.textContent =
                                    firstChild.textContent.replace(
                                        /^GM:\s*/,
                                        "",
                                    );
                            }
                        }
                    }
                });

                // Process RULE paragraphs to add book icon
                paragraphs.forEach((p) => {
                    if (p.getAttribute("data-type") === "rule") {
                        const text = p.textContent.trim();
                        const match = text.match(/^RULE\[([^\]]+)\]:/);

                        if (match) {
                            const ruleRef = match[1].trim();

                            const iconSpan = document.createElement("span");
                            iconSpan.className = "rule-icon";

                            const bookSpan = document.createElement("span");
                            bookSpan.className = "book-icon";
                            bookSpan.textContent = "üìñ";
                            iconSpan.appendChild(bookSpan);

                            const refSpan = document.createElement("span");
                            refSpan.className = "rule-ref";
                            refSpan.textContent = ruleRef;
                            iconSpan.appendChild(refSpan);

                            p.insertBefore(iconSpan, p.firstChild);

                            // Hide the original RULE[ref]: tag
                            const firstChild = p.childNodes[1];
                            if (
                                firstChild &&
                                firstChild.nodeType === Node.TEXT_NODE &&
                                firstChild.textContent
                            ) {
                                firstChild.textContent =
                                    firstChild.textContent.replace(
                                        /^RULE\[[^\]]+\]:\s*/,
                                        "",
                                    );
                            }
                        }
                    }
                });

                // Process NARR paragraphs to hide the tag
                paragraphs.forEach((p) => {
                    if (p.getAttribute("data-type") === "narr") {
                        const text = p.textContent.trim();
                        if (text.startsWith("NARR:")) {
                            // Hide the NARR: tag
                            const firstChild = p.firstChild;
                            if (
                                firstChild &&
                                firstChild.nodeType === Node.TEXT_NODE &&
                                firstChild.textContent
                            ) {
                                firstChild.textContent =
                                    firstChild.textContent.replace(
                                        /^NARR:\s*/,
                                        "",
                                    );
                            }
                        }
                    }
                });

                console.log("Character icons added");
            } catch (e) {
                console.error("Error parsing character data:", e);
            }
        }

        // STEP 2: Setup mode switching
        console.log("=== STEP 2: Setting up mode switching ===");

        // Load saved mode from localStorage
        const savedMode = localStorage.getItem("replayViewMode") || "completo";
        setMode(savedMode);

        buttons.forEach((button) => {
            button.addEventListener("click", () => {
                const mode = button.dataset.mode;
                setMode(mode);
                localStorage.setItem("replayViewMode", mode);
            });
        });

        function setMode(mode) {
            // Update active button
            buttons.forEach((btn) => {
                btn.classList.toggle("active", btn.dataset.mode === mode);
            });

            // Update content visibility
            if (replayContent) {
                replayContent.className = `lore-text mode-${mode}`;
                console.log(`Mode changed to: ${mode}`);
                console.log(`Content class: ${replayContent.className}`);

                // Count visible paragraphs
                const allP = replayContent.querySelectorAll("p");

                // DEBUG: Check if paragraphs have data-type
                const withDataType = Array.from(allP).filter((p) =>
                    p.hasAttribute("data-type"),
                );
                console.log(
                    `Paragraphs with data-type: ${withDataType.length} / ${allP.length}`,
                );
                if (withDataType.length > 0) {
                    console.log(
                        "Sample data-types:",
                        withDataType
                            .slice(0, 3)
                            .map((p) => p.getAttribute("data-type"))
                            .join(", "),
                    );
                }

                const visibleP = Array.from(allP).filter((p) => {
                    const style = window.getComputedStyle(p);
                    return style.display !== "none";
                });
                console.log(
                    `Visible paragraphs: ${visibleP.length} / ${allP.length}`,
                );

                // DEBUG: Check CSS for a paragraph that should be hidden
                if (mode !== "completo" && withDataType.length > 0) {
                    const shouldBeHidden = Array.from(allP).find((p) => {
                        const type = p.getAttribute("data-type");
                        if (mode === "novela")
                            return [
                                "player",
                                "gm",
                                "roll",
                                "rule",
                                "meta",
                            ].includes(type);
                        if (mode === "mesa")
                            return ["roll", "rule", "meta"].includes(type);
                        if (mode === "reglas")
                            return ["char", "player", "gm", "meta"].includes(
                                type,
                            );
                        return false;
                    });

                    if (shouldBeHidden) {
                        const computedStyle =
                            window.getComputedStyle(shouldBeHidden);
                        console.log("DEBUG: Paragraph that should be hidden:");
                        console.log(
                            "  data-type:",
                            shouldBeHidden.getAttribute("data-type"),
                        );
                        console.log("  display:", computedStyle.display);
                        console.log("  visibility:", computedStyle.visibility);
                        console.log("  classes:", shouldBeHidden.className);
                        console.log(
                            "  parent classes:",
                            shouldBeHidden.parentElement?.className,
                        );
                    }
                }

                // Debug: show first few visible paragraphs
                if (visibleP.length < allP.length) {
                    console.log("Sample visible paragraphs:");
                    visibleP.slice(0, 3).forEach((p, i) => {
                        console.log(
                            `  ${i}: ${p.getAttribute("data-type")} - ${p.textContent.substring(0, 40)}...`,
                        );
                    });
                }
            } else {
                console.error("Replay content element not found!");
            }
        }

        console.log("=== Setup complete ===");
    });
</script>
